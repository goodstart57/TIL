# Graph

그래프는 아이템(사물 or 추상적 개념)들의 연결 관계를 표현한다.

그래프는 정점(Vertext)들의 집합과 이들을 연결하는 간선(Edge)들의 집합으로 구성된 자료 구조

- M : 정점의 개수, |E| : 그래프에 포함된 간선의 개수
- M개의 정점을 가지는 그래프의 간선은 최대 `M * (M - 1) / 2`개를 가질 수 있다.
- N : N 관계를 가지는 원소들을 표현 (트리, 선형 자료구조로 표현하기 어려움)



## 그래프 유형

- 무향 그래프 (Undirected Graph)
- 유향 그래프 (Directed Graph)
- 가중치 그래프 (Weighted Graph)
- 사이클 없는 방향 그래프 (DAG, Directed Acyclic Graph)

- 완전 그래프
  - 정점들에 대해 가능한 모든 간선들을 가진 그래프
- 부분 그래프 (sub graph)
  - 원래 그래프에서 일부의 정점/간선을 제외한 그래프



## 그래프 용어

### 인접

- 두개의 정점이 간선으로 연결되면 서로 인접되어있다고 한다.
- 완전 그래프에 속한 임의의 두 정점은 모두 인접해있다.

### 경로

- 간선들을 순서대로 나열한 것
- `단순 경로` : 경로 중 한 정점을 최대 한 번만 지나는 경로
- `사이클(Cycle)` : 시작한 정점에서 끝나는 경로

## 그래프 표현

### 인접 행렬

- M x M 크기의 2차원 배열(MxM 정방 행렬)을 이용하여 간선 정보를 저장
- 행/열 번호는 그래프의 정점에 대응
- 두 정점이 인접되어 있으면 1, 그렇지 않으면 0

- `무향 그래프` : 행 i의 합 = 열 i의 합 = Vi의 차수
- `유향 그래프` : 행 i의 합 == Vi의 진출 차수; 열 i의 합 == Vi의 진입 차수
- `단점` : 메모리 낭비

### 인접 리스트

- 각 정점 마다 해당 정점으로 나가는 간선의 정보를 순차적으로 저장
- 하나의 정점에 대한 인접 정점들을 각각 노드로 하는 연결 리스트로 저장

### 간선의 배열

- 간선을 배열에 연속적으로 저장



## 그래프 순회 (탐색)

### 깊이 우선 탐색 (DFS; Depth First Search)

```python
def dfs_recursive(G, v):
    visited[v] = True // 방문
    for w in adjacency(G, v):
        if not visited[w]:
            dfs_recursive(G, w)
```

```python
s = Stack()
visited = [...]
def dfs(v):
    push(s, v)
    while not s.is_empty():
        v = s.pop()
        if not visited[v]:
            visited[v] = True
        	for w in adjacency(v):
                if not visited[w]:
                    s.push(w)
```



### 너비 우선 탐색 (BFS; Breath First Search)





## 최소신장트리(MST)

- 트리라서 사이클이 없다
- 그래프에서 최소 비용 문제
  - 모든 정점을 연결하는 간선들의 가중치의 합이 최소가 되는 트리
  - 두 정점 사이의 최소 비용의 경로 찾기
- 신장 트리
  - n개의 정점으로 이루어진 무향 그래프에서 n개의 정점과 n-1개의 간선으로 이루어진 트리
- 최소신장트리 (Minimum Spanning Tree)
  - 무향 가중치 그래프에서 신장 트리를 구성하는 간선들의 가중치의 합이 최소인 신장트리



### Prim 알고리즘

- 하나의 정점에서 연결된 간선들 중에 하나씩 선택하면서 MST 생성
  1. 원래 집합 + 정점 집합 두개의 집합 운영 (정점 중심)
  2. 임의의 정점 하나 선택
  3. 선택한 정점과 인접하는 정점들 중 최소 비용의 간선이 존재하는 정점을 선택
  4. (2), (3)과정을 통해 모든 정점이 선택되어 n개의 정점을 모두 옮기면 끝난다.

- Python code

```python
def mst_prim(G, r):
    for u in G.V:
        u.key = INFINITE
        u.pi = None
    u.key = 0
    Q = G.V
    while Q != 0:
        u = extract_min(Q)
        for v in Q.adjacency[u]:
            if v in Q and w(u, v) < v.key:
                v.pi = u
                v.key = w(u, v)
```



### KRUSKAL 알고리즘

- 간선을 하나씩 선택해서 MST를 찾는 알고리즘
  1. 최초, 모든 간선을 가중치에 따라 오름차순으로 정렬
  2. 가중치가 가장 낮은 간선부터 선택하면서 트리를 증가시킴
     - 사이클이 존재하면 다음으로 가중치가 낮은 간선 선택
  3. n - 1개의 간선이 선택될 때 까지 (2) 반복





| 알고리즘                | 가중치 | 모든정점 경유 |
| ----------------------- | ------ | ------------- |
| BFS                     | X      | X             |
| 다익스트라, 플로이드    | O      | X             |
| TSP, 순열, 가지치기, DP | O      | O             |



### 최단 경로